<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SAP Cloud Integration XSLT Editor - Monaco Editor</title>

    <link rel="stylesheet" href="style.css">


</head>
<body>

<header>
    <div class="logo">SAP Cloud Integration XSLT Editor</div>
</header>

<div class="toolbar">
    <select id="example-select">
        <option value="">üìö Choose an Example...</option>
        <option value="basic">Basic XML to XML</option>
        <option value="html">XML to HTML Table</option>
        <option value="filter">Data Filtering</option>
        <option value="group">Grouping Example</option>
        <option value="json">JSON-like Output</option>
        <option value="complex">Complex Document</option>
    </select>
    <button id="run-btn">‚ñ∂Ô∏è RUN TRANSFORMATION</button>
</div>

<div class="main-layout">
    <div class="editor-box">
        <div class="section-header">
            <div class="label">üì• XML Input</div>
            <div class="section-buttons">
                <button class="btn-sec" onclick="formatXML()">‚ú® Format</button>
                <button class="btn-sec" onclick="downloadXML()">üíæ Download</button>
            </div>
        </div>
        <div id="xml-editor" class="editor-container"></div>
    </div>
    <div class="editor-box">
        <div class="section-header">
            <div class="label">üîÑ XSLT 3.0 Stylesheet</div>
            <div class="section-buttons">
                <button class="btn-sec" onclick="formatXSLT()">‚ú® Format</button>
                <button class="btn-sec" onclick="downloadXSLT()">üíæ Download</button>
            </div>
        </div>
        <div id="xslt-editor" class="editor-container"></div>
    </div>
    <div id="result-panel">
        <div class="section-header">
            <div class="label">üì§ Output</div>
            <div class="section-buttons">
                <button class="btn-sec" onclick="formatOutput()">‚ú® Format</button>
                <button class="btn-sec" onclick="downloadOutput()">üíæ Download</button>
            </div>
        </div>
        <div id="output-editor" class="editor-container"></div>
    </div>
</div>

<!-- Console Panel -->
<div id="console-panel">
    <div class="console-header">
        <div class="console-label">
            <span class="console-icon">üñ•Ô∏è</span>
            Console
            <span id="error-count" class="error-count">0</span>
        </div>
        <div class="console-controls">
            <button id="clear-console" class="console-btn" title="Clear Console">üóëÔ∏è</button>
            <button id="toggle-console" class="console-btn" title="Toggle Console">‚ñº</button>
        </div>
    </div>
    <div id="console-content" class="console-content">
        <div id="console-output" class="console-output">
            <div class="console-welcome">Console ready. Transformation errors and runtime problems will appear here.</div>
        </div>
    </div>
</div>

<script src="lib/SaxonJS2.js"></script>
<script src="lib/examples.js"></script>

<script type="module">
    import * as monaco from 'https://cdn.jsdelivr.net/npm/monaco-editor@0.55.1/+esm';

    let xmlEditor, xsltEditor, outputEditor;
    let consoleMessages = [];
    let isConsoleCollapsed = false;

    // XML Pretty Print function
    function prettyPrintXML(xml) {
        let formatted = '';
        let indent = 0;
        const tab = '    '; // 4 spaces

        // First, normalize whitespace
        xml = xml.replace(/>\s+</g, '><').replace(/<\s+/g, '<').replace(/\s+>/g, '>').trim();

        // Split into tokens: tags and text
        const tokens = xml.split(/(<[^>]*>)/).filter(token => token.trim());

        let i = 0;
        while (i < tokens.length) {
            let token = tokens[i].trim();
            if (!token) {
                i++;
                continue;
            }

            if (token.startsWith('</')) {
                // Closing tag
                indent = Math.max(0, indent - 1);
                formatted += tab.repeat(indent) + token + '\n';
            } else if (token.startsWith('<') && token.endsWith('/>')) {
                // Self-closing tag
                formatted += tab.repeat(indent) + token + '\n';
            } else if (token.startsWith('<') && !token.includes('?>')) {
                // Opening tag - check if it has simple text content
                const openingTag = token;
                const nextToken = tokens[i + 1]?.trim();
                const afterNext = tokens[i + 2]?.trim();

                if (nextToken && !nextToken.startsWith('<') && afterNext && afterNext.startsWith('</')) {
                    // Simple text content - keep on same line
                    const textContent = nextToken;
                    const closingTag = afterNext;
                    formatted += tab.repeat(indent) + openingTag + textContent + closingTag + '\n';
                    i += 2; // Skip the next two tokens
                } else {
                    // Complex content - normal formatting
                    formatted += tab.repeat(indent) + token + '\n';
                    indent++;
                }
            } else if (token.startsWith('<?')) {
                // Processing instruction
                formatted += tab.repeat(indent) + token + '\n';
            } else {
                // Text content (for complex cases)
                formatted += tab.repeat(indent) + token + '\n';
            }
            i++;
        }

        return formatted.trim();
    }

    // Console management functions
    function addConsoleMessage(type, message, details = '') {
        const timestamp = new Date().toLocaleTimeString();
        const messageObj = {
            type,
            message,
            details,
            timestamp,
            id: Date.now() + Math.random()
        };

        consoleMessages.push(messageObj);
        updateConsoleDisplay();
        updateErrorCount();
    }

    function clearConsole() {
        consoleMessages = [];
        updateConsoleDisplay();
        updateErrorCount();
    }

    function toggleConsole() {
        isConsoleCollapsed = !isConsoleCollapsed;
        const consoleContent = document.getElementById('console-content');
        const toggleBtn = document.getElementById('toggle-console');

        if (isConsoleCollapsed) {
            consoleContent.classList.add('collapsed');
            toggleBtn.classList.add('rotated');
        } else {
            consoleContent.classList.remove('collapsed');
            toggleBtn.classList.remove('rotated');
        }
    }

    function updateConsoleDisplay() {
        const consoleOutput = document.getElementById('console-output');
        const welcomeMsg = document.querySelector('.console-welcome');

        if (consoleMessages.length === 0) {
            consoleOutput.innerHTML = '<div class="console-welcome">Console ready. Transformation errors and runtime problems will appear here.</div>';
            return;
        }

        if (welcomeMsg) {
            welcomeMsg.remove();
        }

        consoleOutput.innerHTML = consoleMessages.map(msg => `
            <div class="console-message ${msg.type}">
                <div class="timestamp">${msg.timestamp}</div>
                <div class="content">${msg.message}${msg.details ? '\n' + msg.details : ''}</div>
            </div>
        `).join('');

        // Auto-scroll to bottom
        consoleOutput.scrollTop = consoleOutput.scrollHeight;
    }

    function updateErrorCount() {
        const errorCount = consoleMessages.filter(msg => msg.type === 'error').length;
        const errorCountEl = document.getElementById('error-count');
        errorCountEl.textContent = errorCount;
        errorCountEl.setAttribute('data-count', errorCount);
    }

    // Wait for DOM to be ready before initializing Monaco
    document.addEventListener('DOMContentLoaded', function() {
        console.log('DOM loaded, initializing Monaco Editor...');

        // Define custom theme to match the dark design
        monaco.editor.defineTheme('custom-dark', {
            base: 'vs-dark',
            inherit: true,
            rules: [
                { token: 'comment', foreground: '64748b' },
                { token: 'keyword', foreground: 'c792ea' },
                { token: 'string', foreground: 'c3e88d' },
                { token: 'number', foreground: 'f78c6c' }
            ],
            colors: {
                'editor.background': '#1a1a2e',
                'editor.foreground': '#e2e8f0',
                'editor.lineHighlightBackground': '#16213e',
                'editor.selectionBackground': '#334155',
                'editorCursor.foreground': '#6366f1'
            }
        });



        initializeEditors();
    });

    function initializeEditors() {
        console.log('Initializing Monaco editors...');

        // Check if SaxonJS2.js loaded correctly
        if (typeof SaxonJS === 'undefined') {
            console.error("Library not found in /lib/SaxonJS2.js");
            return;
        }

        // Setup Monaco Editors with default values
        const xmlOptions = {
            value: `<?xml version="1.0" encoding="UTF-8"?>
<data>
    <user id="1" role="admin">Alice</user>
    <user id="2" role="editor">Bob</user>
</data>`,
            language: 'xml',
            theme: 'custom-dark',
            fontSize: 14,
            fontFamily: "'Fira Code', 'JetBrains Mono', 'Consolas', monospace",
            lineNumbers: 'on',
            roundedSelection: false,
            scrollBeyondLastLine: false,
            automaticLayout: true,
            minimap: { enabled: false },
            wordWrap: 'on',
            tabSize: 2,
            insertSpaces: true
        };

        const xsltOptions = {
            value: `<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="3.0">
    <xsl:output method="xml" indent="yes"/>

    <xsl:template match="/">
        <report date="{current-date()}">
            <xsl:apply-templates select="//user"/>
        </report>
    </xsl:template>

    <xsl:template match="user">
        <entry name="{.}" type="{@role}"/>
    </xsl:template>
</xsl:stylesheet>`,
            language: 'xml',
            theme: 'custom-dark',
            fontSize: 14,
            fontFamily: "'Fira Code', 'JetBrains Mono', 'Consolas', monospace",
            lineNumbers: 'on',
            roundedSelection: false,
            scrollBeyondLastLine: false,
            automaticLayout: true,
            minimap: { enabled: false },
            wordWrap: 'on',
            tabSize: 2,
            insertSpaces: true
        };

        const outputOptions = {
            value: "Press Run to see results...",
            language: 'xml',
            theme: 'custom-dark',
            fontSize: 14,
            fontFamily: "'Fira Code', 'JetBrains Mono', 'Consolas', monospace",
            lineNumbers: 'on',
            roundedSelection: false,
            scrollBeyondLastLine: false,
            automaticLayout: true,
            minimap: { enabled: false },
            wordWrap: 'on',
            tabSize: 2,
            insertSpaces: true,
            readOnly: true
        };

        // Register XML formatter
        monaco.languages.registerDocumentFormattingEditProvider('xml', {
            provideDocumentFormattingEdits: function(model) {
                const xml = model.getValue();
                const formatted = prettyPrintXML(xml);
                return [{
                    range: model.getFullModelRange(),
                    text: formatted
                }];
            }
        });

        console.log('Creating XML editor...');
        xmlEditor = monaco.editor.create(document.getElementById('xml-editor'), xmlOptions);
        console.log('Creating XSLT editor...');
        xsltEditor = monaco.editor.create(document.getElementById('xslt-editor'), xsltOptions);
        console.log('Creating output editor...');
        outputEditor = monaco.editor.create(document.getElementById('output-editor'), outputOptions);

        // Add keyboard shortcuts
        xmlEditor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {
            document.getElementById('run-btn').click();
        });
        xsltEditor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {
            document.getElementById('run-btn').click();
        });

        console.log('Monaco editors initialized with default demo data');

        // Add console control event listeners
        document.getElementById('clear-console').addEventListener('click', clearConsole);
        document.getElementById('toggle-console').addEventListener('click', toggleConsole);

        // Add real-time validation
        xsltEditor.onDidChangeModelContent(() => {
            validateXSLT(xsltEditor);
        });

        // Initial validation
        validateXSLT(xsltEditor);

        // The Transformation Logic
        document.getElementById('run-btn').addEventListener('click', async () => {
            const runBtn = document.getElementById('run-btn');
            const originalText = runBtn.textContent;

            // Add loading state
            runBtn.textContent = "‚è≥ PROCESSING...";
            runBtn.disabled = true;
            runBtn.classList.add('loading');

            outputEditor.setValue("üîÑ Transforming XML...");
            addConsoleMessage('info', 'Transformation: Starting XSLT processing...');

            try {
                const result = SaxonJS.XPath.evaluate(`
                    transform(map {
                        'stylesheet-text' : $xslt,
                        'source-node' : parse-xml($xml),
                        'delivery-format' : 'serialized'
                    })?output`,
                    [],
                    {
                        params: {
                            xslt: xsltEditor.getValue(),
                            xml: xmlEditor.getValue()
                        }
                    }
                );

                outputEditor.setValue(result);
                addConsoleMessage('success', 'Transformation: Completed successfully');

            } catch (err) {
                console.error(err);
                const errorMessage = err.message || 'Unknown transformation error';
                outputEditor.setValue("‚ùå Transformation Error:\n" + errorMessage);
                addConsoleMessage('error', `Transformation: ${errorMessage}`);
            } finally {
                // Reset button state
                runBtn.textContent = originalText;
                runBtn.disabled = false;
                runBtn.classList.remove('loading');
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 's':
                        e.preventDefault();
                        downloadResult();
                        break;
                    case 'p':
                        e.preventDefault();
                        formatAll();
                        break;
                }
            }
        });

        // Example selector
        document.getElementById('example-select').addEventListener('change', (e) => {
            const selectedExample = e.target.value;
            if (selectedExample && examples[selectedExample]) {
                xmlEditor.setValue(examples[selectedExample].xml);
                xsltEditor.setValue(examples[selectedExample].xslt);
                outputEditor.setValue("Example loaded! Press Run to see results...");
            }
        });
    }

    // Formatting Tool
    function formatAll() {
        const format = (v) => v.replace(/>\s*</g, '><').replace(/<([^?\/!][^>]*?)\/>/g, '<$1 />').replace(/>(?=<)/g, '>\n');
        xmlEditor.setValue(format(xmlEditor.getValue()));
        xsltEditor.setValue(format(xsltEditor.getValue()));
    }

    // Per-section formatting using Monaco's built-in formatter
    function formatXML() {
        xmlEditor.trigger('', 'editor.action.formatDocument');
    }

    function formatXSLT() {
        xsltEditor.trigger('', 'editor.action.formatDocument');
    }

    function formatOutput() {
        // Temporarily make output editable for formatting
        outputEditor.updateOptions({ readOnly: false });
        outputEditor.trigger('', 'editor.action.formatDocument');
        // Make it read-only again after a short delay
        setTimeout(() => {
            outputEditor.updateOptions({ readOnly: true });
        }, 100);
    }

    // Download Tool
    function downloadResult() {
        downloadContent(outputEditor.getValue(), 'result.xml');
    }

    // Per-section download
    function downloadXML() {
        downloadContent(xmlEditor.getValue(), 'xml-input.xml');
    }

    function downloadXSLT() {
        downloadContent(xsltEditor.getValue(), 'xslt-stylesheet.xsl');
    }

    function downloadOutput() {
        downloadContent(outputEditor.getValue(), 'output.xml');
    }

    // General download function
    function downloadContent(text, filename) {
        const blob = new Blob([text], {type: "text/xml"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
    }

    // Make functions global for onclick handlers
    window.formatXML = formatXML;
    window.formatXSLT = formatXSLT;
    window.formatOutput = formatOutput;
    window.downloadXML = downloadXML;
    window.downloadXSLT = downloadXSLT;
    window.downloadOutput = downloadOutput;

    // XSLT Validation Function
    function validateXSLT(editor) {
        const model = editor.getModel();
        if (!model) return;

        const content = model.getValue();
        const markers = [];

        // Basic XML well-formedness check
        const xmlErrors = validateXMLStructure(content);
        markers.push(...xmlErrors);

        // XSLT-specific validation
        const xsltErrors = validateXSLTSyntax(content);
        markers.push(...xsltErrors);

        // XPath expression validation
        const xpathErrors = validateXPathExpressions(content);
        markers.push(...xpathErrors);

        // Only set warning markers (no red error underscores)
        const warningMarkers = markers.filter(marker => marker.severity === monaco.MarkerSeverity.Warning);
        monaco.editor.setModelMarkers(model, 'xslt', warningMarkers);
    }

    // Validate basic XML structure
    function validateXMLStructure(content) {
        const errors = [];
        const lines = content.split('\n');

        // Check for unclosed tags
        const tagStack = [];
        // Updated regex to be more robust with tag name extraction
        const tagRegex = /<\/?([a-zA-Z_:][\w:.-]*)(?:\s[^>]*)?>/g;
        let match;
        let lineNum = 0;

        while ((match = tagRegex.exec(content)) !== null) {
            const tag = match[0];
            const tagName = match[1];
            const charIndex = match.index;

            // Skip if tagName is empty (shouldn't happen with our regex, but safety check)
            if (!tagName || tagName.trim() === '') {
                continue;
            }

            // Find which line this tag is on
            let currentLineStart = 0;
            for (let i = 0; i < lines.length; i++) {
                const lineEnd = currentLineStart + lines[i].length + 1; // +1 for newline
                if (charIndex >= currentLineStart && charIndex < lineEnd) {
                    lineNum = i;
                    break;
                }
                currentLineStart = lineEnd;
            }

            if (tag.startsWith('</')) {
                // Closing tag
                if (tagStack.length === 0) {
                    errors.push({
                        severity: monaco.MarkerSeverity.Error,
                        message: `Unexpected closing tag </${tagName}>`,
                        startLineNumber: lineNum + 1,
                        startColumn: charIndex - content.lastIndexOf('\n', charIndex) + 1,
                        endLineNumber: lineNum + 1,
                        endColumn: charIndex - content.lastIndexOf('\n', charIndex) + tag.length + 1
                    });
                } else {
                    const lastTag = tagStack.pop();
                    if (lastTag !== tagName) {
                        errors.push({
                            severity: monaco.MarkerSeverity.Error,
                            message: `Mismatched tags: expected </${lastTag}>, found </${tagName}>`,
                            startLineNumber: lineNum + 1,
                            startColumn: charIndex - content.lastIndexOf('\n', charIndex) + 1,
                            endLineNumber: lineNum + 1,
                            endColumn: charIndex - content.lastIndexOf('\n', charIndex) + tag.length + 1
                        });
                    }
                }
            } else if (!tag.endsWith('/>')) {
                // Opening tag (not self-closing)
                tagStack.push(tagName);
            }
            // Self-closing tags like <br/> are ignored (not pushed to stack)
        }

        // Check for unclosed tags at end
        while (tagStack.length > 0) {
            const unclosedTag = tagStack.pop();
            errors.push({
                severity: monaco.MarkerSeverity.Error,
                message: `Unclosed tag <${unclosedTag}>`,
                startLineNumber: lines.length,
                startColumn: 1,
                endLineNumber: lines.length,
                endColumn: lines[lines.length - 1].length + 1
            });
        }

        return errors;
    }

    // Validate XSLT-specific syntax
    function validateXSLTSyntax(content) {
        const errors = [];
        const lines = content.split('\n');

        // Check for required xsl:stylesheet or xsl:transform root element
        const rootMatch = content.match(/<(\w+:)?stylesheet[^>]*>|<(\w+:)?transform[^>]*>/);
        if (!rootMatch && content.trim().length > 0) {
            errors.push({
                severity: monaco.MarkerSeverity.Warning,
                message: 'XSLT document should start with <xsl:stylesheet> or <xsl:transform>',
                startLineNumber: 1,
                startColumn: 1,
                endLineNumber: 1,
                endColumn: content.indexOf('>') + 1 || content.length + 1
            });
        }

        // Check for missing namespace declaration
        if (!content.includes('xmlns:xsl="http://www.w3.org/1999/XSL/Transform"') &&
            !content.includes("xmlns:xsl='http://www.w3.org/1999/XSL/Transform'")) {
            errors.push({
                severity: monaco.MarkerSeverity.Warning,
                message: 'Missing XSL namespace declaration',
                startLineNumber: 1,
                startColumn: 1,
                endLineNumber: 1,
                endColumn: Math.min(50, content.length + 1)
            });
        }

        // Check for xsl:template without match or name attribute
        const templateRegex = /<xsl:template([^>]*)>/g;
        let templateMatch;
        while ((templateMatch = templateRegex.exec(content)) !== null) {
            const attrs = templateMatch[1];
            if (!attrs.includes('match=') && !attrs.includes('name=')) {
                const charIndex = templateMatch.index;
                let lineNum = 0;
                while (lineNum < lines.length && charIndex >= content.indexOf(lines[lineNum], charIndex - templateMatch[0].length)) {
                    lineNum++;
                }
                lineNum = Math.max(0, lineNum - 1);

                errors.push({
                    severity: monaco.MarkerSeverity.Error,
                    message: 'xsl:template must have either match or name attribute',
                    startLineNumber: lineNum + 1,
                    startColumn: charIndex - content.lastIndexOf('\n', charIndex) + 1,
                    endLineNumber: lineNum + 1,
                    endColumn: charIndex - content.lastIndexOf('\n', charIndex) + templateMatch[0].length + 1
                });
            }
        }

        return errors;
    }

    // Validate XPath expressions
    function validateXPathExpressions(content) {
        const errors = [];
        const lines = content.split('\n');

        // Find XPath expressions in select, test, and match attributes
        const xpathAttrs = ['select', 'test', 'match'];
        const attrRegex = new RegExp(`(${xpathAttrs.join('|')})\\s*=\\s*["']([^"']*)["']`, 'gi');

        let attrMatch;
        while ((attrMatch = attrRegex.exec(content)) !== null) {
            const attrName = attrMatch[1];
            const xpathExpr = attrMatch[2];
            const charIndex = attrMatch.index;

            let lineNum = 0;
            while (lineNum < lines.length && charIndex >= content.indexOf(lines[lineNum], charIndex - attrMatch[0].length)) {
                lineNum++;
            }
            lineNum = Math.max(0, lineNum - 1);

            // Basic XPath validation
            const xpathErrors = validateXPathSyntax(xpathExpr);
            if (xpathErrors.length > 0) {
                errors.push({
                    severity: monaco.MarkerSeverity.Error,
                    message: `Invalid XPath in ${attrName} attribute: ${xpathErrors[0]}`,
                    startLineNumber: lineNum + 1,
                    startColumn: charIndex - content.lastIndexOf('\n', charIndex) + attrMatch[0].indexOf('"') + 1,
                    endLineNumber: lineNum + 1,
                    endColumn: charIndex - content.lastIndexOf('\n', charIndex) + attrMatch[0].indexOf('"') + xpathExpr.length + 2
                });
            }
        }

        return errors;
    }

    // Basic XPath syntax validation
    function validateXPathSyntax(xpath) {
        const errors = [];

        try {
            // Check for balanced brackets
            let bracketCount = 0;
            let inString = false;
            let stringChar = '';
            let inComment = false;

            for (let i = 0; i < xpath.length; i++) {
                const char = xpath[i];
                const nextChar = xpath[i + 1] || '';

                // Handle strings
                if (!inString && !inComment && (char === '"' || char === "'")) {
                    inString = true;
                    stringChar = char;
                } else if (inString && char === stringChar && xpath[i - 1] !== '\\') {
                    inString = false;
                    stringChar = '';
                }
                // Skip comments (basic handling)
                else if (!inString && char === '(' && nextChar === ':') {
                    // This is a simplified comment detection
                    // XPath comments are (: ... :) but this is complex to parse
                }

                // Only check brackets when not in strings or comments
                if (!inString && !inComment) {
                    if (char === '[') bracketCount++;
                    if (char === ']') bracketCount--;
                    if (bracketCount < 0) {
                        errors.push('Unmatched closing bracket');
                        break;
                    }
                }
            }
            if (bracketCount > 0) {
                errors.push('Unmatched opening bracket');
            }

            // Check for balanced parentheses
            let parenCount = 0;
            inString = false;
            stringChar = '';

            for (let i = 0; i < xpath.length; i++) {
                const char = xpath[i];

                // Handle strings
                if (!inString && (char === '"' || char === "'")) {
                    inString = true;
                    stringChar = char;
                } else if (inString && char === stringChar && xpath[i - 1] !== '\\') {
                    inString = false;
                    stringChar = '';
                }

                // Only check parentheses when not in strings
                if (!inString) {
                    if (char === '(') parenCount++;
                    if (char === ')') parenCount--;
                    if (parenCount < 0) {
                        errors.push('Unmatched closing parenthesis');
                        break;
                    }
                }
            }
            if (parenCount > 0) {
                errors.push('Unmatched opening parenthesis');
            }

            // More lenient character validation - allow more XPath characters
            const cleanedXPath = xpath.replace(/'.*?'|".*?"/g, ''); // Remove strings
            if (/[^\w\s.\-/@\[\]\(\)\*\+\|!=<>&:,]/.test(cleanedXPath)) {
                // Allow common XPath characters, but flag obviously wrong ones
                const invalidChars = cleanedXPath.match(/[^\w\s.\-/@\[\]\(\)\*\+\|!=<>&:,]/g);
                if (invalidChars && invalidChars.some(char => !['/', '#', '$', '?', '^'].includes(char))) {
                    errors.push('Potentially invalid characters in XPath expression');
                }
            }

        } catch (e) {
            // If validation fails, don't report XPath errors
            return [];
        }

        return errors;
    }

    // Helper functions for XSLT IntelliSense
    function getXSLTElements() {
        return [
            {
                name: 'stylesheet',
                snippet: 'stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="3.0">\n\t$1\n</stylesheet>',
                documentation: 'Root element of XSLT stylesheet'
            },
            {
                name: 'template',
                snippet: 'template match="$1">\n\t$2\n</template>',
                documentation: 'Defines a template rule'
            },
            {
                name: 'for-each',
                snippet: 'for-each select="$1">\n\t$2\n</for-each>',
                documentation: 'Iterates over a sequence of items'
            },
            {
                name: 'if',
                snippet: 'if test="$1">\n\t$2\n</if>',
                documentation: 'Conditional processing'
            },
            {
                name: 'choose',
                snippet: 'choose>\n\t<xsl:when test="$1">\n\t\t$2\n\t</xsl:when>\n\t<xsl:otherwise>\n\t\t$3\n\t</xsl:otherwise>\n</choose>',
                documentation: 'Multiple conditional processing'
            },
            {
                name: 'when',
                snippet: 'when test="$1">\n\t$2\n</when>',
                documentation: 'When condition in choose'
            },
            {
                name: 'otherwise',
                snippet: 'otherwise>\n\t$1\n</otherwise>',
                documentation: 'Otherwise condition in choose'
            },
            {
                name: 'value-of',
                snippet: 'value-of select="$1"/>',
                documentation: 'Outputs the value of an expression'
            },
            {
                name: 'copy-of',
                snippet: 'copy-of select="$1"/>',
                documentation: 'Copies a node and its descendants'
            },
            {
                name: 'apply-templates',
                snippet: 'apply-templates select="$1"/>',
                documentation: 'Applies templates to selected nodes'
            },
            {
                name: 'call-template',
                snippet: 'call-template name="$1"/>',
                documentation: 'Calls a named template'
            },
            {
                name: 'variable',
                snippet: 'variable name="$1" select="$2"/>',
                documentation: 'Declares a variable'
            },
            {
                name: 'param',
                snippet: 'param name="$1" select="$2"/>',
                documentation: 'Declares a parameter'
            },
            {
                name: 'output',
                snippet: 'output method="$1" indent="yes"/>',
                documentation: 'Controls the format of the output'
            }
        ];
    }

    function getXSLTElementAttributes(elementName) {
        const attributeMap = {
            'template': ['match', 'name', 'mode', 'priority'],
            'for-each': ['select'],
            'if': ['test'],
            'when': ['test'],
            'value-of': ['select', 'disable-output-escaping'],
            'copy-of': ['select'],
            'apply-templates': ['select', 'mode'],
            'call-template': ['name'],
            'variable': ['name', 'select'],
            'param': ['name', 'select'],
            'output': ['method', 'version', 'encoding', 'omit-xml-declaration', 'standalone', 'doctype-public', 'doctype-system', 'indent', 'media-type'],
            'stylesheet': ['version', 'xmlns:xsl']
        };
        return attributeMap[elementName] || [];
    }

    function getAttributeDocumentation(elementName, attributeName) {
        const docs = {
            'template': {
                'match': 'Pattern to match nodes',
                'name': 'Name of the template for call-template',
                'mode': 'Mode to apply this template in',
                'priority': 'Priority of this template rule'
            },
            'for-each': {
                'select': 'XPath expression selecting nodes to iterate over'
            },
            'if': {
                'test': 'Boolean expression for conditional processing'
            },
            'value-of': {
                'select': 'XPath expression to evaluate',
                'disable-output-escaping': 'Whether to disable output escaping'
            },
            'variable': {
                'name': 'Name of the variable',
                'select': 'XPath expression for variable value'
            }
        };
        return docs[elementName]?.[attributeName] || `Attribute for ${elementName} element`;
    }

    function getXPathFunctions() {
        return [
            {
                name: 'count()',
                snippet: 'count($1)',
                documentation: 'Returns the number of items in a sequence'
            },
            {
                name: 'string()',
                snippet: 'string($1)',
                documentation: 'Converts to string'
            },
            {
                name: 'number()',
                snippet: 'number($1)',
                documentation: 'Converts to number'
            },
            {
                name: 'boolean()',
                snippet: 'boolean($1)',
                documentation: 'Converts to boolean'
            },
            {
                name: 'current-date()',
                snippet: 'current-date()',
                documentation: 'Returns the current date'
            },
            {
                name: 'current-time()',
                snippet: 'current-time()',
                documentation: 'Returns the current time'
            },
            {
                name: 'current-dateTime()',
                snippet: 'current-dateTime()',
                documentation: 'Returns the current date and time'
            },
            {
                name: 'position()',
                snippet: 'position()',
                documentation: 'Returns the position of the current node'
            },
            {
                name: 'last()',
                snippet: 'last()',
                documentation: 'Returns the size of the context'
            },
            {
                name: 'name()',
                snippet: 'name()',
                documentation: 'Returns the name of the current node'
            },
            {
                name: 'local-name()',
                snippet: 'local-name()',
                documentation: 'Returns the local name of the current node'
            },
            {
                name: 'namespace-uri()',
                snippet: 'namespace-uri()',
                documentation: 'Returns the namespace URI of the current node'
            },
            {
                name: 'text()',
                snippet: 'text()',
                documentation: 'Selects text nodes'
            },
            {
                name: 'node()',
                snippet: 'node()',
                documentation: 'Selects any node'
            },
            {
                name: 'comment()',
                snippet: 'comment()',
                documentation: 'Selects comment nodes'
            },
            {
                name: 'processing-instruction()',
                snippet: 'processing-instruction()',
                documentation: 'Selects processing instruction nodes'
            }
        ];
    }
</script>

</body>
</html>
